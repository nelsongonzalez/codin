{"version":3,"file":"event-observer.js","sourceRoot":"","sources":["../src/build/event-observer.ts"],"names":[],"mappings":"AAIA;;;;GAIG;AACH,MAAM,OAAO,aAAa;IAEzB,YACW,GAA6B,EAC7B,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE;QADxB,QAAG,GAAH,GAAG,CAA0B;QAC7B,SAAI,GAAJ,IAAI,CAAoB;QAHzB,wBAAmB,GAA2B,IAAI,GAAG,EAAE,CAAC;IAI/D,CAAC;IAEJ;;;;OAIG;IACI,OAAO,CAAC,OAAgB,EAAE,IAAY;QACzC,MAAM,WAAW,GAAG,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QAChE,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;YAChC,OAAO,CAAC,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YAChD,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,OAAO,EAAE,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QACpE,CAAC,CAAC,EAAE,CAAC;IACT,CAAC;IAED;;;;;OAKG;IACI,SAAS,CAAC,OAAgB,EAAE,IAAa;QAC5C,MAAM,WAAW,GAAG,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QAChE,MAAM,WAAW,GAAG,IAAI,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;QAC5F,MAAM,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QACxE,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;QACjE,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAC3H,CAAC;IAED;;;OAGG;IACI,WAAW,CAAC,EAAK;QACpB,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;IACvB,CAAC;CACD;AACD,eAAe,aAAa,CAAC","sourcesContent":["export interface EventObserverCallback<T extends Event> {\n (event: T, observer: EventObserver<T>): void;\n}\n\n/**\n * Wrapper class for mapping events to a callback.\n * Observe and unobserve without redefining callback.\n * Hold reference to callback.\n */\nexport class EventObserver<T extends Event> {\n protected _observationTargets: Map<Element, string[]> = new Map();\n constructor(\n  protected _cb: EventObserverCallback<T>,\n  protected _opt = { passive: true }\n ) {}\n\n /**\n  * Observers an element type of event\n  * @param element element to observe\n  * @param type type of event to observe\n  */\n public observe(element: Element, type: string) {\n     const targetTypes = this._observationTargets.get(element) || [];\n     targetTypes.includes(type) || (() => {\n         element.addEventListener(type, this, this._opt);\n         this._observationTargets.set(element, targetTypes.concat(type));\n     })();\n }\n\n /**\n  * Stops listening for event on element.\n  * If no type provided, all registered events are removed.\n  * @param element element to unregister event listening\n  * @param type type of event to stop listen for\n  */\n public unobserve(element: Element, type?: string) {\n     const targetTypes = this._observationTargets.get(element) || [];\n     const removeTypes = type && targetTypes.includes(type) ? [type] : (type ? [] : targetTypes);\n     const remainTypes = targetTypes.filter((t) => !removeTypes.includes(t));\n     removeTypes.forEach((t) => element.removeEventListener(t, this));\n     remainTypes.length > 0 ? this._observationTargets.set(element, remainTypes) : this._observationTargets.delete(element);\n }\n\n /**\n  * Internal proxy for callbacks.\n  * @param ev Event\n  */\n public handleEvent(ev: T) {\n     this._cb(ev, this);\n }\n}\nexport default EventObserver;"]}